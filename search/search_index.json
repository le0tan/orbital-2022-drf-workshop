{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the website for Orbital 2022 Workshop: Django and Django REST Framework. Getting Started Source Code","title":"Home"},{"location":"django_models/","text":"Overview of Entities Course string name float price OrderItem Course course string special_requirements enum status pending preparing ready delivered Table int table_number string location Order OrderItem[] items int calling_number this number is self-incremental, resets every day Table table enum status preapring ready delivered Basic Field Types (Records) Numbers IntegerField FloatField Text CharField: for text with known/max length TextField: for paragraphs of text Others BooleanField DateField FileField Let's take Course model as an example: Create a new Python package models under app/models folder; create course.py with the following: from django.db import models class Course ( models . Model ): name = models . CharField ( max_length = 128 ) price = models . FloatField () def __str__ ( self ): return f 'Course - { self . name } - $ { self . price } ' In app/models/__init__.py , add the following: from app.models.course import * Register the model in Django admin: in app/admin.py from django.contrib import admin from app.models import Course # Register your models here. admin . site . register ( Course ) Make migrations: python manage.py makemigrations Migrate: python manage.py migrate Then you should be able to access localhost:8000/admin to manage the Course model... but wait! What's our username and password? Glad you asked - you may use python manage.py createsuperuser to create the user. Common Field Options ref: https://docs.djangoproject.com/en/4.0/ref/models/fields/#field-options null blank choices default unique unique_for_date ~month ~year ForeignKey (Many-To-One Relationship) ref: https://docs.djangoproject.com/en/4.0/ref/models/fields/#django.db.models.ForeignKey The relationship between OrderItem and Order is a classic many-to-one relationship: an order item belongs to one and only one order, and an order may include many order items. To model this relationship, we use ForeignKey field in Django model. There are two required arguments for a ForeignKey field: to and on_delete : to : the model we refer to, it can be the model class ( app.models.Order ) or the model name ( Order ). If you want to create a self-referential foreign key, use 'self' . on_delete : what happens if the target object is deleted. For example, what should we do to the order items if the order is deleted? There are many possible options defined in django.db.models , here are some common ones: CASCADE: the order items will be deleted PROTECT: if there exists an order that at least one order item refers to, you cannot delete this order unless all related order items are deleted. SET_NULL: order item will refer to a NULL order SET_DEFAULT: similar to SET_NULL, but set to the default value ManyToManyField ref: https://docs.djangoproject.com/en/4.0/ref/models/fields/#manytomanyfield to: the model we refer to same as ForeignKey NOTE: unlike ForeignKey, no on_delete option is provided because the underlying implementation is by creating a relational entity! Example: Students <-> Courses, Group <-> User (later) CRUD with Django Shell ref: https://docs.djangoproject.com/en/4.0/intro/tutorial02/#playing-with-the-api >>> from app.models import Course , Order , OrderItem , Table # List objects >>> Course . objects . all () < QuerySet [ < Course : Course - Chicken Rice - $ 3.5 > ] > # Create >>> c = Course ( name = 'Big Mac' , price = 5.5 ) >>> c . save () >>> Course . objects . all () < QuerySet [ < Course : Course - Chicken Rice - $ 3.5 > , < Course : Course - Big Mac - $ 5.5 > ] > # Read properties >>> c . name 'Big Mac' # Update object >>> c . name = 'Big Big Mac' >>> c . save () >>> Course . objects . all () < QuerySet [ < Course : Course - Chicken Rice - $ 3.5 > , < Course : Course - Big Big Mac - $ 5.5 > ] > # Delete object >>> bbm = Course . objects . all ()[ 1 ] >>> bbm . delete () ( 1 , { 'app.Course' : 1 }) >>> Course . objects . all () < QuerySet [ < Course : Course - Chicken Rice - $ 3.5 > ] > # Filter >>> Order . objects . filter ( status = Order . STATUS_DELIVERED ) < QuerySet [ < Order : Order [ 1 ] - Table 1 - D > , < Order : Order [ 2 ] - Table 1 - D > ] > >>> Order . objects . filter ( table__location = 'Left' ) < QuerySet [ < Order : Order [ 1 ] - Table 1 - D > , < Order : Order [ 2 ] - Table 1 - D > ] >","title":"Django Models"},{"location":"django_models/#overview-of-entities","text":"Course string name float price OrderItem Course course string special_requirements enum status pending preparing ready delivered Table int table_number string location Order OrderItem[] items int calling_number this number is self-incremental, resets every day Table table enum status preapring ready delivered","title":"Overview of Entities"},{"location":"django_models/#basic-field-types-records","text":"Numbers IntegerField FloatField Text CharField: for text with known/max length TextField: for paragraphs of text Others BooleanField DateField FileField Let's take Course model as an example: Create a new Python package models under app/models folder; create course.py with the following: from django.db import models class Course ( models . Model ): name = models . CharField ( max_length = 128 ) price = models . FloatField () def __str__ ( self ): return f 'Course - { self . name } - $ { self . price } ' In app/models/__init__.py , add the following: from app.models.course import * Register the model in Django admin: in app/admin.py from django.contrib import admin from app.models import Course # Register your models here. admin . site . register ( Course ) Make migrations: python manage.py makemigrations Migrate: python manage.py migrate Then you should be able to access localhost:8000/admin to manage the Course model... but wait! What's our username and password? Glad you asked - you may use python manage.py createsuperuser to create the user.","title":"Basic Field Types (Records)"},{"location":"django_models/#common-field-options","text":"ref: https://docs.djangoproject.com/en/4.0/ref/models/fields/#field-options null blank choices default unique unique_for_date ~month ~year","title":"Common Field Options"},{"location":"django_models/#foreignkey-many-to-one-relationship","text":"ref: https://docs.djangoproject.com/en/4.0/ref/models/fields/#django.db.models.ForeignKey The relationship between OrderItem and Order is a classic many-to-one relationship: an order item belongs to one and only one order, and an order may include many order items. To model this relationship, we use ForeignKey field in Django model. There are two required arguments for a ForeignKey field: to and on_delete : to : the model we refer to, it can be the model class ( app.models.Order ) or the model name ( Order ). If you want to create a self-referential foreign key, use 'self' . on_delete : what happens if the target object is deleted. For example, what should we do to the order items if the order is deleted? There are many possible options defined in django.db.models , here are some common ones: CASCADE: the order items will be deleted PROTECT: if there exists an order that at least one order item refers to, you cannot delete this order unless all related order items are deleted. SET_NULL: order item will refer to a NULL order SET_DEFAULT: similar to SET_NULL, but set to the default value","title":"ForeignKey (Many-To-One Relationship)"},{"location":"django_models/#manytomanyfield","text":"ref: https://docs.djangoproject.com/en/4.0/ref/models/fields/#manytomanyfield to: the model we refer to same as ForeignKey NOTE: unlike ForeignKey, no on_delete option is provided because the underlying implementation is by creating a relational entity! Example: Students <-> Courses, Group <-> User (later)","title":"ManyToManyField"},{"location":"django_models/#crud-with-django-shell","text":"ref: https://docs.djangoproject.com/en/4.0/intro/tutorial02/#playing-with-the-api >>> from app.models import Course , Order , OrderItem , Table # List objects >>> Course . objects . all () < QuerySet [ < Course : Course - Chicken Rice - $ 3.5 > ] > # Create >>> c = Course ( name = 'Big Mac' , price = 5.5 ) >>> c . save () >>> Course . objects . all () < QuerySet [ < Course : Course - Chicken Rice - $ 3.5 > , < Course : Course - Big Mac - $ 5.5 > ] > # Read properties >>> c . name 'Big Mac' # Update object >>> c . name = 'Big Big Mac' >>> c . save () >>> Course . objects . all () < QuerySet [ < Course : Course - Chicken Rice - $ 3.5 > , < Course : Course - Big Big Mac - $ 5.5 > ] > # Delete object >>> bbm = Course . objects . all ()[ 1 ] >>> bbm . delete () ( 1 , { 'app.Course' : 1 }) >>> Course . objects . all () < QuerySet [ < Course : Course - Chicken Rice - $ 3.5 > ] > # Filter >>> Order . objects . filter ( status = Order . STATUS_DELIVERED ) < QuerySet [ < Order : Order [ 1 ] - Table 1 - D > , < Order : Order [ 2 ] - Table 1 - D > ] > >>> Order . objects . filter ( table__location = 'Left' ) < QuerySet [ < Order : Order [ 1 ] - Table 1 - D > , < Order : Order [ 2 ] - Table 1 - D > ] >","title":"CRUD with Django Shell"},{"location":"django_permissions/","text":"When we initialized this Django project, we were already prompted to create a superuser. In Django, users are represented with a special model named User . Here's an example of creating a new user via shell: >>> from django.contrib.auth.models import User >>> user = User . objects . create_user ( 'john' , 'lennon@thebeatles.com' , 'johnpassword' ) # At this point, user is a User object that has already been saved # to the database. You can continue to change its attributes # if you want to change other fields. >> > user . last_name = 'Lennon' >> > user . save () There are two many-to-many fields of User related to permission management: groups and user_permissions . As mentioned earlier, User is a model just like any other ones, so you can perform CRUD on these fields as shown below: myuser . groups . set ([ group_list ]) myuser . groups . add ( group , group , ... ) myuser . groups . remove ( group , group , ... ) myuser . groups . clear () myuser . user_permissions . set ([ permission_list ]) myuser . user_permissions . add ( permission , permission , ... ) myuser . user_permissions . remove ( permission , permission , ... ) myuser . user_permissions . clear () Default Permissions By default (if you followed the earlier instructions on creating the project and DB migration, and didn't mess up with the boilerplate code) Django will create four Permission s for each model you migrated: add, change, delete and view. For example, in our case, our application is named app , and our model is named Course , then you can check these four permissions by: add: user.has_perm('app.add_course') change: user.has_perm('app.change_course') delete: user.has_perm('app.delete_course') view: user.has_perm('app.view_course') >>> from django.contrib.auth.models import User >>> user = User . objects . get ( username = 'leo' ) >>> user . has_perm ( 'app.add_course' ) True Custom Permissions Besides the four default permissions for each model, you can also create custom permission as shown below: from app.models import Course from django.contrib.auth.models import Permission from django.contrib.contenttypes.models import ContentType content_type = ContentType . objects . get_for_model ( Course ) permission = Permission . objects . create ( codename = 'can_custom_ops' , name = 'Can Perform Some Custom Operation' , content_type = content_type , ) NOTE: ContentType is basically a representation of models in your Django application. For more details, refer to the contenttypes framework . Groups A user in a group automatically has the permissions granted to that group. Here's an example: from django.contrib.auth.models import Group , Permission , User # Create a group named staff staff_group = Group ( name = 'staff' ) staff_group . save () # Get the permission app.view_course and assign it to staff group p = Permission . objects . get ( content_type__app_label = 'app' , codename = 'view_course' ) staff_group . permissions . add ( p ) # Assign myuser to the staff group myuser = User . objects . get ( username = \"myuser\" ) myuser . groups . add ( staff_group ) # Check myuser has staff group's permissions >>> myuser . has_perm ( \"app.view_course\" ) True For more details about Django authentication system, read here .","title":"Django Permissions"},{"location":"django_permissions/#default-permissions","text":"By default (if you followed the earlier instructions on creating the project and DB migration, and didn't mess up with the boilerplate code) Django will create four Permission s for each model you migrated: add, change, delete and view. For example, in our case, our application is named app , and our model is named Course , then you can check these four permissions by: add: user.has_perm('app.add_course') change: user.has_perm('app.change_course') delete: user.has_perm('app.delete_course') view: user.has_perm('app.view_course') >>> from django.contrib.auth.models import User >>> user = User . objects . get ( username = 'leo' ) >>> user . has_perm ( 'app.add_course' ) True","title":"Default Permissions"},{"location":"django_permissions/#custom-permissions","text":"Besides the four default permissions for each model, you can also create custom permission as shown below: from app.models import Course from django.contrib.auth.models import Permission from django.contrib.contenttypes.models import ContentType content_type = ContentType . objects . get_for_model ( Course ) permission = Permission . objects . create ( codename = 'can_custom_ops' , name = 'Can Perform Some Custom Operation' , content_type = content_type , ) NOTE: ContentType is basically a representation of models in your Django application. For more details, refer to the contenttypes framework .","title":"Custom Permissions"},{"location":"django_permissions/#groups","text":"A user in a group automatically has the permissions granted to that group. Here's an example: from django.contrib.auth.models import Group , Permission , User # Create a group named staff staff_group = Group ( name = 'staff' ) staff_group . save () # Get the permission app.view_course and assign it to staff group p = Permission . objects . get ( content_type__app_label = 'app' , codename = 'view_course' ) staff_group . permissions . add ( p ) # Assign myuser to the staff group myuser = User . objects . get ( username = \"myuser\" ) myuser . groups . add ( staff_group ) # Check myuser has staff group's permissions >>> myuser . has_perm ( \"app.view_course\" ) True For more details about Django authentication system, read here .","title":"Groups"},{"location":"drf/","text":"Django Rest Framework: The Basics Installation pip install djangorestframework pip install markdown # Markdown support for the browsable API. pip install django-filter # Filtering support Setup Add 'rest_framework' to your INSTALLED_APPS setting (in ordersys/settings.py ). INSTALLED_APPS = [ ... 'rest_framework' , ] Add the browsable API to ordersys/urls.py from rest_framework import routers from django.shortcuts import redirect router = routers . DefaultRouter () urlpatterns = [ path ( '' , lambda req : redirect ( 'api/' )), # redirects the index URL to API root path ( 'api/' , include ( router . urls )), path ( 'admin/' , admin . site . urls ), ] (Temporary) set default authentication class to BasicAuthentication (in settings.py ) # DRF REST_FRAMEWORK = { 'DEFAULT_AUTHENTICATION_CLASSES' : [ 'rest_framework.authentication.BasicAuthentication' , ] } Quick Demo After the setup, you should be able to access the DRF browsable API at localhost:8000/api/ , but it's useless for now as we haven't add any API yet! While we we cover the how-to very soon, here's a very short demo on how easy it is to add a new API: from django.contrib import admin from django.urls import path , include from django.shortcuts import redirect from rest_framework import routers , viewsets , serializers , permissions from app.models import Course class CourseSerializer ( serializers . ModelSerializer ): class Meta : model = Course fields = '__all__' class CourseViewSet ( viewsets . ModelViewSet ): queryset = Course . objects . all () serializer_class = CourseSerializer permission_classes = [ permissions . IsAuthenticated ] router = routers . DefaultRouter () router . register ( r 'courses' , CourseViewSet ) urlpatterns = [ path ( '' , lambda req : redirect ( 'api/' )), # redirects the index URL to API root path ( 'api/' , include ( router . urls )), path ( 'admin/' , admin . site . urls ), ] Overview There are three key concepts/components that you need to understand for this workshop: Serializers : convert Django models (which is in Python object format) to API response (which is in JSON format), and vice versa. Viewsets : a high-level abstraction provided by DRF that handles URL construction automatically based on common conventions, and leaves developers to focus on API behavior itself. Routers : a utility used alongside viewsets that automatically wires URLs to corresponding views. NOTE: If you refer to the DRF documentation, you'll realize that we skipped part 2 to 5 of the 6-part tutorial. Feel free to read the documentation for more primitive usage of DRF, and the trade-offs between views and viewsets . Writing the API Create new module app/serializers ; create new file course.py for CourseSerializer . from rest_framework import serializers from app.models import Course class CourseSerializer ( serializers . ModelSerializer ): class Meta : model = Course fields = '__all__' Create new module app/apis ; create new file course.py for CourseViewSet . from rest_framework import viewsets , permissions from app.models import Course from app.serializers import CourseSerializer class CourseViewSet ( viewsets . ModelViewSet ): queryset = Course . objects . all () serializer_class = CourseSerializer permission_classes = [ permissions . IsAuthenticated ] Register CourseViewSet in the router (in ordersys/urls.py ). from rest_framework import routers from app.apis import CourseViewSet router = routers . DefaultRouter () router . register ( r 'courses' , CourseViewSet ) urlpatterns = [ path ( 'api/' , include ( router . urls )), ... ] Now you have a fully functional REST API for the Course model! It supports CRUD and is authenticated by username and password. It's easier than you thought, right? Django Rest Framework: Customization We can follow the previous section to create REST APIs for other models, but only that would be too boring and trivial wouldn't it? Let's look at some more advanced customization of DRF. Permission Management Reference: DRF Permissions In the definition of CourseViewSet , we have a line permission_classes = [permissions.IsAuthenticated] which uses DRF's built-in permission class IsAuthenticated . As the name suggests, authenticated users will have full permissions (i.e., read, change, delete) to the viewset. There are 6 other permissions provided by DRF: AllowAny : obvious... IsAdminUser : when user.is_staff is true (Only those with staff status can log into Django admin site) IsAuthenticatedOrReadOnly DjangoModelPermissions : follows Django's standard django.contrib.auth model permissions. This might be the most frequently used permissions for you. DjangoModelPermissionsOrAnonReadOnly : returns read-only view for non-authenticated user DjangoObjectPermissions : this thing is not officially supported by Django, and you need to learn about corresponding backend such as django-guardian , so we'll skip it for now (but we'll create our own object-level permission later). Custom Permissions Besides using built-in permissions, since DRF is an object-oriented framework, we can extend these permissions for our own needs. There are two methods in a Permission class: has_permission(self, request, view) for model-level permission has_object_permission(self, request, view, obj) for object-level permission For example, if you only want people to view, edit and add, but not delete Table , you can write the following custom permission: from rest_framework import viewsets , permissions from app.models import Table from app.serializers import TableSerializer class TablePermissions ( permissions . IsAuthenticated ): def has_permission ( self , request , view ): if not super ( TablePermissions , self ) . has_permission ( request , view ): return False if request . method in [ \"DELETE\" ]: return False return True class TableViewSet ( viewsets . ModelViewSet ): queryset = Table . objects . all () serializer_class = TableSerializer permission_classes = [ TablePermissions ] For example, if you don't know DjangoModelPermissions exists, you can still realize the same functionality by extending IsAuthenticated : from rest_framework import viewsets , permissions from app.models import Course from app.serializers import CourseSerializer class CoursePermissions ( permissions . IsAuthenticated ): def has_object_permission ( self , request , view , obj ): course = obj # for better code competion in PyCharm if request . user . is_superuser : return True elif request . method in permissions . SAFE_METHODS : return request . user . has_perm ( 'app.view_course' ) elif request . method == 'POST' : return request . user . has_perm ( 'app.add_course' ) elif request . method == 'PUT' : return request . user . has_perm ( 'app.change_course' ) elif request . method == 'DELETE' : return request . user . has_perm ( 'app.delete_course' ) return False class CourseViewSet ( viewsets . ModelViewSet ): queryset = Course . objects . all () serializer_class = CourseSerializer permission_classes = [ CoursePermissions ] Customize Serializers Ref: DRF ModelSerializer In our previous example, we included all fields by letting fields = '__all__' in the Meta class. We can do much more: Include a subset of fields class AccountSerializer ( serializers . ModelSerializer ): class Meta : model = Account fields = [ 'id' , 'account_name' , 'users' , 'created' ] Exclude certain fields class AccountSerializer ( serializers . ModelSerializer ): class Meta : model = Account exclude = [ 'users' ] Nested serialization: if you look at the default response of http://127.0.0.1:8000/api/orders/6/ you should see the following: { \"id\" : 6 , \"date\" : \"2022-05-17\" , \"calling_number\" : 1 , \"status\" : \"C\" , \"table\" : 1 } Here table is a foreign key field, however the details about this object is not serialized and only the primary key 1 is shown here. Nested serialization means DRF will recursively serialize these objects up until depth . Below is an example: class OrderSerializer ( serializers . ModelSerializer ): class Meta : model = Order fields = '__all__' depth = 1 # NEW Then the response becomes: { \"id\" : 6 , \"date\" : \"2022-05-17\" , \"calling_number\" : 1 , \"status\" : \"C\" , \"table\" : { \"id\" : 1 , \"index\" : 1 , \"location\" : \"Left\" } } Specify read only fields class AccountSerializer ( serializers . ModelSerializer ): class Meta : model = Account fields = [ 'id' , 'account_name' , 'users' , 'created' ] read_only_fields = [ 'account_name' ] There are many more customizations you can do to the ModelSerializer . If you have interest, you may refer to the DRF documentation for more details. Filtering Ref: DRF Filtering For querying data, besides simply listing the objects (with or without pagination), DRF also supports filtering, ordering and searching. You may specify the filter backend by setting filter_backends property of your viewset class. Filtering backend: django_filters.rest_framework.DjangoFilterBackend config: filterset_fields = [...] Ordering backend: rest_framework.filters.OrderingFilter config: ordering_fields = [...] Searching backend: rest_framework.filters.SearchFilter config: search_fields = [...] Below are examples of applying these filters: from rest_framework import viewsets , permissions from app.models import Order from app.serializers import OrderSerializer from django_filters.rest_framework import DjangoFilterBackend from rest_framework import filters class OrderViewSet ( viewsets . ModelViewSet ): queryset = Order . objects . all () serializer_class = OrderSerializer permissions = [ permissions . DjangoModelPermissions ] filter_backends = [ DjangoFilterBackend , filters . OrderingFilter ] filterset_fields = [ 'status' , 'table' ] ordering_fields = [ 'date' ] from rest_framework import viewsets , permissions , filters from app.models import Table from app.serializers import TableSerializer class TableViewSet ( viewsets . ModelViewSet ): queryset = Table . objects . all () serializer_class = TableSerializer permission_classes = [ TablePermissions ] filter_backends = [ filters . SearchFilter ] search_fields = [ 'location' ] Extra Actions Ref: DRF ViewSet Extra Actions Of course your REST API can include custom functionality beyond CRUD on the models. To implement extra actions, you may use @action decorator on top of your method. Say you want to have an API /orders/:id/deliver_order that marks an order as delivered, you may write the following method in OrderViewSet : from rest_framework import decorators , response @decorators . action ( detail = True , methods = [ 'get' ]) def deliver_order ( self , request , pk = None ): order = self . get_object () order . status = Order . STATUS_DELIVERED order . save () return response . Response ({ 'status' : 'ok' , 'order' : OrderSerializer ( order ) . data }) Here we set detail=True because this is an object-level method, which means this action is applicable only when we have a specific object to work with. In this case, we can invoke self.get_object() method to fetch the current object. Say you want to have an API /orders/deliver_all_orders that marks all orders as delivered, you may have the following: @decorators . action ( detail = False , methods = [ 'get' ]) def deliver_all_orders ( self , request ): for order in Order . objects . all (): order . status = Order . STATUS_DELIVERED order . save () return response . Response ({ 'status' : 'ok' }) Unlike the previous one, since we don't need a specific order to operate on, we set detail=False and this action works on model-level .","title":"Django REST Framework"},{"location":"drf/#django-rest-framework-the-basics","text":"","title":"Django Rest Framework: The Basics"},{"location":"drf/#installation","text":"pip install djangorestframework pip install markdown # Markdown support for the browsable API. pip install django-filter # Filtering support","title":"Installation"},{"location":"drf/#setup","text":"Add 'rest_framework' to your INSTALLED_APPS setting (in ordersys/settings.py ). INSTALLED_APPS = [ ... 'rest_framework' , ] Add the browsable API to ordersys/urls.py from rest_framework import routers from django.shortcuts import redirect router = routers . DefaultRouter () urlpatterns = [ path ( '' , lambda req : redirect ( 'api/' )), # redirects the index URL to API root path ( 'api/' , include ( router . urls )), path ( 'admin/' , admin . site . urls ), ] (Temporary) set default authentication class to BasicAuthentication (in settings.py ) # DRF REST_FRAMEWORK = { 'DEFAULT_AUTHENTICATION_CLASSES' : [ 'rest_framework.authentication.BasicAuthentication' , ] }","title":"Setup"},{"location":"drf/#quick-demo","text":"After the setup, you should be able to access the DRF browsable API at localhost:8000/api/ , but it's useless for now as we haven't add any API yet! While we we cover the how-to very soon, here's a very short demo on how easy it is to add a new API: from django.contrib import admin from django.urls import path , include from django.shortcuts import redirect from rest_framework import routers , viewsets , serializers , permissions from app.models import Course class CourseSerializer ( serializers . ModelSerializer ): class Meta : model = Course fields = '__all__' class CourseViewSet ( viewsets . ModelViewSet ): queryset = Course . objects . all () serializer_class = CourseSerializer permission_classes = [ permissions . IsAuthenticated ] router = routers . DefaultRouter () router . register ( r 'courses' , CourseViewSet ) urlpatterns = [ path ( '' , lambda req : redirect ( 'api/' )), # redirects the index URL to API root path ( 'api/' , include ( router . urls )), path ( 'admin/' , admin . site . urls ), ]","title":"Quick Demo"},{"location":"drf/#overview","text":"There are three key concepts/components that you need to understand for this workshop: Serializers : convert Django models (which is in Python object format) to API response (which is in JSON format), and vice versa. Viewsets : a high-level abstraction provided by DRF that handles URL construction automatically based on common conventions, and leaves developers to focus on API behavior itself. Routers : a utility used alongside viewsets that automatically wires URLs to corresponding views. NOTE: If you refer to the DRF documentation, you'll realize that we skipped part 2 to 5 of the 6-part tutorial. Feel free to read the documentation for more primitive usage of DRF, and the trade-offs between views and viewsets .","title":"Overview"},{"location":"drf/#writing-the-api","text":"Create new module app/serializers ; create new file course.py for CourseSerializer . from rest_framework import serializers from app.models import Course class CourseSerializer ( serializers . ModelSerializer ): class Meta : model = Course fields = '__all__' Create new module app/apis ; create new file course.py for CourseViewSet . from rest_framework import viewsets , permissions from app.models import Course from app.serializers import CourseSerializer class CourseViewSet ( viewsets . ModelViewSet ): queryset = Course . objects . all () serializer_class = CourseSerializer permission_classes = [ permissions . IsAuthenticated ] Register CourseViewSet in the router (in ordersys/urls.py ). from rest_framework import routers from app.apis import CourseViewSet router = routers . DefaultRouter () router . register ( r 'courses' , CourseViewSet ) urlpatterns = [ path ( 'api/' , include ( router . urls )), ... ] Now you have a fully functional REST API for the Course model! It supports CRUD and is authenticated by username and password. It's easier than you thought, right?","title":"Writing the API"},{"location":"drf/#django-rest-framework-customization","text":"We can follow the previous section to create REST APIs for other models, but only that would be too boring and trivial wouldn't it? Let's look at some more advanced customization of DRF.","title":"Django Rest Framework: Customization"},{"location":"drf/#permission-management","text":"Reference: DRF Permissions In the definition of CourseViewSet , we have a line permission_classes = [permissions.IsAuthenticated] which uses DRF's built-in permission class IsAuthenticated . As the name suggests, authenticated users will have full permissions (i.e., read, change, delete) to the viewset. There are 6 other permissions provided by DRF: AllowAny : obvious... IsAdminUser : when user.is_staff is true (Only those with staff status can log into Django admin site) IsAuthenticatedOrReadOnly DjangoModelPermissions : follows Django's standard django.contrib.auth model permissions. This might be the most frequently used permissions for you. DjangoModelPermissionsOrAnonReadOnly : returns read-only view for non-authenticated user DjangoObjectPermissions : this thing is not officially supported by Django, and you need to learn about corresponding backend such as django-guardian , so we'll skip it for now (but we'll create our own object-level permission later).","title":"Permission Management"},{"location":"drf/#custom-permissions","text":"Besides using built-in permissions, since DRF is an object-oriented framework, we can extend these permissions for our own needs. There are two methods in a Permission class: has_permission(self, request, view) for model-level permission has_object_permission(self, request, view, obj) for object-level permission For example, if you only want people to view, edit and add, but not delete Table , you can write the following custom permission: from rest_framework import viewsets , permissions from app.models import Table from app.serializers import TableSerializer class TablePermissions ( permissions . IsAuthenticated ): def has_permission ( self , request , view ): if not super ( TablePermissions , self ) . has_permission ( request , view ): return False if request . method in [ \"DELETE\" ]: return False return True class TableViewSet ( viewsets . ModelViewSet ): queryset = Table . objects . all () serializer_class = TableSerializer permission_classes = [ TablePermissions ] For example, if you don't know DjangoModelPermissions exists, you can still realize the same functionality by extending IsAuthenticated : from rest_framework import viewsets , permissions from app.models import Course from app.serializers import CourseSerializer class CoursePermissions ( permissions . IsAuthenticated ): def has_object_permission ( self , request , view , obj ): course = obj # for better code competion in PyCharm if request . user . is_superuser : return True elif request . method in permissions . SAFE_METHODS : return request . user . has_perm ( 'app.view_course' ) elif request . method == 'POST' : return request . user . has_perm ( 'app.add_course' ) elif request . method == 'PUT' : return request . user . has_perm ( 'app.change_course' ) elif request . method == 'DELETE' : return request . user . has_perm ( 'app.delete_course' ) return False class CourseViewSet ( viewsets . ModelViewSet ): queryset = Course . objects . all () serializer_class = CourseSerializer permission_classes = [ CoursePermissions ]","title":"Custom Permissions"},{"location":"drf/#customize-serializers","text":"Ref: DRF ModelSerializer In our previous example, we included all fields by letting fields = '__all__' in the Meta class. We can do much more: Include a subset of fields class AccountSerializer ( serializers . ModelSerializer ): class Meta : model = Account fields = [ 'id' , 'account_name' , 'users' , 'created' ] Exclude certain fields class AccountSerializer ( serializers . ModelSerializer ): class Meta : model = Account exclude = [ 'users' ] Nested serialization: if you look at the default response of http://127.0.0.1:8000/api/orders/6/ you should see the following: { \"id\" : 6 , \"date\" : \"2022-05-17\" , \"calling_number\" : 1 , \"status\" : \"C\" , \"table\" : 1 } Here table is a foreign key field, however the details about this object is not serialized and only the primary key 1 is shown here. Nested serialization means DRF will recursively serialize these objects up until depth . Below is an example: class OrderSerializer ( serializers . ModelSerializer ): class Meta : model = Order fields = '__all__' depth = 1 # NEW Then the response becomes: { \"id\" : 6 , \"date\" : \"2022-05-17\" , \"calling_number\" : 1 , \"status\" : \"C\" , \"table\" : { \"id\" : 1 , \"index\" : 1 , \"location\" : \"Left\" } } Specify read only fields class AccountSerializer ( serializers . ModelSerializer ): class Meta : model = Account fields = [ 'id' , 'account_name' , 'users' , 'created' ] read_only_fields = [ 'account_name' ] There are many more customizations you can do to the ModelSerializer . If you have interest, you may refer to the DRF documentation for more details.","title":"Customize Serializers"},{"location":"drf/#filtering","text":"Ref: DRF Filtering For querying data, besides simply listing the objects (with or without pagination), DRF also supports filtering, ordering and searching. You may specify the filter backend by setting filter_backends property of your viewset class. Filtering backend: django_filters.rest_framework.DjangoFilterBackend config: filterset_fields = [...] Ordering backend: rest_framework.filters.OrderingFilter config: ordering_fields = [...] Searching backend: rest_framework.filters.SearchFilter config: search_fields = [...] Below are examples of applying these filters: from rest_framework import viewsets , permissions from app.models import Order from app.serializers import OrderSerializer from django_filters.rest_framework import DjangoFilterBackend from rest_framework import filters class OrderViewSet ( viewsets . ModelViewSet ): queryset = Order . objects . all () serializer_class = OrderSerializer permissions = [ permissions . DjangoModelPermissions ] filter_backends = [ DjangoFilterBackend , filters . OrderingFilter ] filterset_fields = [ 'status' , 'table' ] ordering_fields = [ 'date' ] from rest_framework import viewsets , permissions , filters from app.models import Table from app.serializers import TableSerializer class TableViewSet ( viewsets . ModelViewSet ): queryset = Table . objects . all () serializer_class = TableSerializer permission_classes = [ TablePermissions ] filter_backends = [ filters . SearchFilter ] search_fields = [ 'location' ]","title":"Filtering"},{"location":"drf/#extra-actions","text":"Ref: DRF ViewSet Extra Actions Of course your REST API can include custom functionality beyond CRUD on the models. To implement extra actions, you may use @action decorator on top of your method. Say you want to have an API /orders/:id/deliver_order that marks an order as delivered, you may write the following method in OrderViewSet : from rest_framework import decorators , response @decorators . action ( detail = True , methods = [ 'get' ]) def deliver_order ( self , request , pk = None ): order = self . get_object () order . status = Order . STATUS_DELIVERED order . save () return response . Response ({ 'status' : 'ok' , 'order' : OrderSerializer ( order ) . data }) Here we set detail=True because this is an object-level method, which means this action is applicable only when we have a specific object to work with. In this case, we can invoke self.get_object() method to fetch the current object. Say you want to have an API /orders/deliver_all_orders that marks all orders as delivered, you may have the following: @decorators . action ( detail = False , methods = [ 'get' ]) def deliver_all_orders ( self , request ): for order in Order . objects . all (): order . status = Order . STATUS_DELIVERED order . save () return response . Response ({ 'status' : 'ok' }) Unlike the previous one, since we don't need a specific order to operate on, we set detail=False and this action works on model-level .","title":"Extra Actions"},{"location":"getting_started/","text":"Installation Django (Will cover later) Django Rest Framework (Will cover later) dj-rest-auth Create Django Project python -m django --version to check you have Django properly installed in your current environment. django-admin startproject ordersys python manage.py migrate (Optional) set TIME_ZONE in settings.py to Asia/Singapore or your local time zone python manage.py runserver Add Django Application Project vs. App Project = configuration (settings.py) + a collection of apps App = a web application that does something An app can appear in multiple projects A project can include multiple apps e.g., Django REST Framework is an app Start an app: python manage.py startapp app Naming is hard, please come up with a more creative name for your own project =) Include app in the project: INSTALLED_APPS from settings.py Add app.apps.AppConfig to the list Django URL (i.e., Router) and View With your Django app properly initialized, you should see the following welcome page: Now let's briefly talk about how to setup a URL router in Django and display our own web page (or in Django terms, view) . Creating a Simple View In app/views.py : from django.http import HttpResponse # Create your views here. def index ( request ): return HttpResponse ( \"Hello world!\" ) We now created a view named index which simply responds with a string of text. Creating Routes to Our View Create a new file app/urls.py : from django.urls import path from . import views urlpatterns = [ # `name` arg is optional, but helpful for `reverse()` function # ref: https://docs.djangoproject.com/en/4.0/topics/http/urls/#naming-url-patterns path ( '' , views . index , name = 'index' ), ] A urls.py file will have a list named urlpatterns , inside which are path s that corresponds to the view s in this app . A path requires two arguments: route and view . route is basically a URL that Django URL Dispatcher attempts to match, and view is the view Django returns if the URL is a match. For more details about Django URL Dispatcher, please refer to here . Update ordersys/urls.py : from django.contrib import admin from django.urls import path , include urlpatterns = [ path ( '' , include ( 'app.urls' )), path ( 'admin/' , admin . site . urls ), ] Remember that app is one of the supposedly many applications in this Django project, and ordersys is the \"root\" of this project. So you may consider ordersys/urls.py as the root router of this project, and we need to include app.urls here to wrap everything up.","title":"Getting Started"},{"location":"getting_started/#installation","text":"Django (Will cover later) Django Rest Framework (Will cover later) dj-rest-auth","title":"Installation"},{"location":"getting_started/#create-django-project","text":"python -m django --version to check you have Django properly installed in your current environment. django-admin startproject ordersys python manage.py migrate (Optional) set TIME_ZONE in settings.py to Asia/Singapore or your local time zone python manage.py runserver","title":"Create Django Project"},{"location":"getting_started/#add-django-application","text":"Project vs. App Project = configuration (settings.py) + a collection of apps App = a web application that does something An app can appear in multiple projects A project can include multiple apps e.g., Django REST Framework is an app Start an app: python manage.py startapp app Naming is hard, please come up with a more creative name for your own project =) Include app in the project: INSTALLED_APPS from settings.py Add app.apps.AppConfig to the list","title":"Add Django Application"},{"location":"getting_started/#django-url-ie-router-and-view","text":"With your Django app properly initialized, you should see the following welcome page: Now let's briefly talk about how to setup a URL router in Django and display our own web page (or in Django terms, view) .","title":"Django URL (i.e., Router) and View"},{"location":"getting_started/#creating-a-simple-view","text":"In app/views.py : from django.http import HttpResponse # Create your views here. def index ( request ): return HttpResponse ( \"Hello world!\" ) We now created a view named index which simply responds with a string of text.","title":"Creating a Simple View"},{"location":"getting_started/#creating-routes-to-our-view","text":"Create a new file app/urls.py : from django.urls import path from . import views urlpatterns = [ # `name` arg is optional, but helpful for `reverse()` function # ref: https://docs.djangoproject.com/en/4.0/topics/http/urls/#naming-url-patterns path ( '' , views . index , name = 'index' ), ] A urls.py file will have a list named urlpatterns , inside which are path s that corresponds to the view s in this app . A path requires two arguments: route and view . route is basically a URL that Django URL Dispatcher attempts to match, and view is the view Django returns if the URL is a match. For more details about Django URL Dispatcher, please refer to here . Update ordersys/urls.py : from django.contrib import admin from django.urls import path , include urlpatterns = [ path ( '' , include ( 'app.urls' )), path ( 'admin/' , admin . site . urls ), ] Remember that app is one of the supposedly many applications in this Django project, and ordersys is the \"root\" of this project. So you may consider ordersys/urls.py as the root router of this project, and we need to include app.urls here to wrap everything up.","title":"Creating Routes to Our View"},{"location":"token_auth/","text":"There's a critical problem with the current implementation: while we can CRUD the models via REST APIs, we cannot register new users in this way! Moreover, we're still using BasicAuthentication which requires username and password for every API call. It's better if we can apply token-based authentication for better security (especially for automated bots). We will use dj-rest-auth , an extension of Django REST Framework, to address these two problems. Installation Follow the instructions . Doing the \"installation\" section is sufficient. There's no need for the optional ones. Besides following the steps, there's one more step you need to do: in ordersys/settings.py , update your DEFAULT_AUTHENTICATION_CLASSES to include rest_framework.authentication.TokenAuthentication : REST_FRAMEWORK = { 'DEFAULT_AUTHENTICATION_CLASSES' : [ 'rest_framework.authentication.BasicAuthentication' , 'rest_framework.authentication.TokenAuthentication' , ], 'DEFAULT_FILTER_BACKENDS' : [ 'django_filters.rest_framework.DjangoFilterBackend' ] } Usage Get token Request: POST 127.0.0.1:8000/dj-rest-auth/login/ Response: {\"key\": \"bca51bf8aa94b4d20d962a30328c606d79310977\"} Access API using token Set header: Authorization: Token <YOUR-TOKEN> You can also do email verification and password reset using dj-rest-auth, I'll leave that for your own exploration.","title":"Token Authentication"},{"location":"token_auth/#installation","text":"Follow the instructions . Doing the \"installation\" section is sufficient. There's no need for the optional ones. Besides following the steps, there's one more step you need to do: in ordersys/settings.py , update your DEFAULT_AUTHENTICATION_CLASSES to include rest_framework.authentication.TokenAuthentication : REST_FRAMEWORK = { 'DEFAULT_AUTHENTICATION_CLASSES' : [ 'rest_framework.authentication.BasicAuthentication' , 'rest_framework.authentication.TokenAuthentication' , ], 'DEFAULT_FILTER_BACKENDS' : [ 'django_filters.rest_framework.DjangoFilterBackend' ] }","title":"Installation"},{"location":"token_auth/#usage","text":"Get token Request: POST 127.0.0.1:8000/dj-rest-auth/login/ Response: {\"key\": \"bca51bf8aa94b4d20d962a30328c606d79310977\"} Access API using token Set header: Authorization: Token <YOUR-TOKEN> You can also do email verification and password reset using dj-rest-auth, I'll leave that for your own exploration.","title":"Usage"}]}